#' Preprocess input data for RSS analysis
#'
#' This function preprocesses summary statistics and LD data for RSS analysis.
#' It performs allele quality control, flipping alleles as necessary, and removes
#' specified regions from the analysis.
#'
#' @param sumstats A data frame containing summary statistics with columns "chrom", "pos", "A1", and "A2".
#' @param LD_data A list containing combined LD variants data that is generated by load_LD_matrix.
#' @param skip_region A character vector specifying regions to be skipped in the analysis (optional).
#'                    Each region should be in the format "chrom:start-end" (e.g., "1:1000000-2000000").
#'
#' @return A list containing the processed summary statistics and LD matrix.
#'   - sumstats: A data frame containing the processed summary statistics.
#'   - LD_mat: The processed LD matrix.
#'
#' @importFrom dplyr filter pull arrange
#' @importFrom tibble tibble
#' @importFrom tidyr separate
#' @importFrom magrittr %>%
#' @export
rss_basic_qc <- function(sumstats, LD_data, skip_region = NULL) {
  # Check if required columns are present in sumstats
  required_cols <- c("chrom", "pos", "A1", "A2")
  missing_cols <- setdiff(required_cols, colnames(sumstats))
  if (length(missing_cols) > 0) {
    stop("Missing columns in sumstats: ", paste(missing_cols, collapse = ", "))
  }

  target_variants <- sumstats[, c("chrom", "pos", "A1", "A2")]
  ref_variants <- LD_data$combined_LD_variants

  allele_flip <- allele_qc(target_variants, ref_variants, sumstats,
    col_to_flip = c("beta", "z"),
    match_min_prop = 0.2, remove_dups = TRUE, remove_indels = FALSE,
    remove_strand_ambiguous = TRUE
  )

  if (!is.null(skip_region)) {
    skip_table <- tibble(region = skip_region) %>%
      separate(region, into = c("chrom", "start", "end"), sep = "[-:]")

    skip_variant <- c()
    for (region_index in 1:nrow(skip_table)) {
      variant <- allele_flip$target_data_qced %>%
        filter(chrom == skip_table$chrom[region_index] &
          pos > skip_table$start[region_index] &
          pos < skip_table$end[region_index]) %>%
        pull(variant_id)
      skip_variant <- c(skip_variant, variant)
    }

    allele_flip$target_data_qced <- allele_flip$target_data_qced %>%
      filter(!(variant_id %in% skip_variant))
  }

  sumstat_processed <- allele_flip$target_data_qced %>% arrange(pos)
  LD_mat_processed <- LD_data$combined_LD_matrix[sumstat_processed$variant_id, sumstat_processed$variant_id, drop = FALSE]

  return(list(sumstats = sumstat_processed, LD_mat = LD_mat_processed))
}


#' Perform Quality Control based on SuSiE RSS
#'
#' This function performs quality control on summary statistics using SuSiE RSS.
#' It identifies and removes outliers based on z-score and LD matrix discrepancy correction.
#'
#' @param sumstats A data frame containing summary statistics with 'variant_id', 'z', and 'pos' columns.
#' @param LD_mat Numeric matrix representing the LD (linkage disequilibrium) matrix.
#' @param L Number of causal configurations to consider in the analysis.
#'
#' @return A list containing the quality-controlled summary statistics and updated LD matrix.
#'   - sumstats_qc: A data frame containing the quality-controlled summary statistics.
#'   - LD_mat_qc: The updated LD matrix excluding outlier variants.
#'
#' @details This function performs quality control on summary statistics using SuSiE RSS.
#'   It first extracts the z-scores from the `sumstats` data frame and performs SuSiE RSS analysis
#'   with discrepancy correction using the `susie_rss` function.
#'   
#'   Next, it identifies outlier variants based on the results of the SuSiE RSS analysis.
#'   It removes the outlier variants from the summary statistics and updates the LD matrix accordingly.
#'   
#'   Finally, it returns a list containing the quality-controlled summary statistics and the updated LD matrix.
#'
#' @importFrom susieR susie_rss
#' @export
susie_rss_qc <- function(sumstats, LD_mat, L = 10) {
  zScore <- sumstats$z
  # Check that LD_mat dimensions match the length of zScore
  if (!is.matrix(LD_mat) || nrow(LD_mat) != ncol(LD_mat) || nrow(LD_mat) != length(zScore)) {
    stop("LD_mat must be a square matrix with dimensions equal to the length of zScore.")
  }
  result <- susie_rss(
    z = zScore, R = LD_mat, L = L,
    correct_zR_discrepancy = TRUE, track_fit = TRUE, max_iter = 100
  )
  
  ## Identify outlier variants
  if (!is.null(result$zR_outliers) & length(result$zR_outliers) != 0) {
    outlier <- result$zR_outliers
    sumstat_qc <- sumstats[-outlier, ]
    LD_extract_qc <- as.matrix(LD_mat)[-outlier, -outlier]
  } else {
    sumstat_qc <- sumstats
    LD_extract_qc <- as.matrix(LD_mat)
  }
  
  return(list(sumstats = sumstat_qc, LD_mat = LD_extract_qc))
}

#' Perform Quality Control and Imputation on Summary Statistics
#'
#' This function performs quality control on the processed summary statistics using the specified method
#' and performs imputation for missing data based on the provided options.
#'
#' @param sumstats A data frame containing the processed summary statistics.
#' @param LD_data A list containing the combined LD variants data generated by load_LD_matrix.
#' @param method The quality control method to use. Options are "rss_qc", "dentist", or "slalom" (default: "rss_qc").
#' @param impute_opts A list of imputation options including:
#'   - rcond: Condition number for the RAiSS imputation method (default: 0.01).
#'   - R2_threshold: R-squared threshold for the RAiSS imputation method (default: 0.6).
#'   - minimum_ld: Minimum number of LD values for the RAiSS imputation method (default: 5).
#'   - lamb: Regularization parameter for the RAiSS imputation method (default: 0.01).
#'
#' @return A list containing the quality-controlled and imputed summary statistics and updated LD matrix.
#'   - sumstats_qc_imputed: The quality-controlled and imputed summary statistics data frame.
#'   - LD_mat_qc_imputed: The updated LD matrix after quality control and imputation.
#'
#' @details This function applies the specified quality control method to the processed summary statistics
#'   and performs imputation for missing data using the RAiSS method based on the provided `impute_opts`.
#'   
#'   The available quality control methods are:
#'   - "rss_qc": Applies the RSS QC quality control procedure (Sun and Dong et al 2023+).
#'   - "dentist": Applies the DENTIST quality control procedure (Chen et al 2021).
#'   - "slalom": Applies the SLALOM quality control procedure.
#'   
#'   The imputation is performed using the RAiSS method with the specified options in `impute_opts`.
#'   The function returns the quality-controlled and imputed summary statistics along with the updated LD matrix.
#'
#' @examples
#' # Perform RSS quality control and imputation
#' qc_impute_results <- summary_stats_qc(sumstats, LD_data, method = "rss_qc",
#'                                       impute_opts = list(rcond = 0.05, R2_threshold = 0.7, minimum_ld = 10, lamb = 0.02))
#'
#' @export
summary_stats_qc <- function(sumstats, LD_data, method = c("rss_qc", "dentist", "slalom"),
                             impute_opts = list(rcond = 0.01, R2_threshold = 0.6, minimum_ld = 5, lamb = 0.01)) {
  # assuming sumstats has been allele QC-ed, using rss_basic_qc() function
  LD_extract <- LD_data$combined_LD_matrix[sumstats$variant_id, sumstats$variant_id, drop = FALSE]
  if (method == "rss_qc") {
    sumstats <- susie_rss_qc(sumstats, LD_extract)$sumstats
  } else {
    stop("Invalid quality control method specified. Available methods are: 'rss_qc', 'dentist', 'slalom'.")
  }

  ## Imputation logic using RAiSS
  imputation_res <- raiss(LD_data$ref_panel, sumstats, LD_data$combined_LD_matrix,
                          lamb = impute_opts$lamb, rcond = impute_opts$rcond,
                          R2_threshold = impute_opts$R2_threshold, minimum_ld = impute_opts$minimum_ld
  )$result_filter
  
  ## Filter out variants not included in the imputation result
  filtered_out_variant <- setdiff(LD_data$ref_panel$variant_id, imputation_res$variant_id)
  
  ## Update the LD matrix excluding filtered variants
  LD_extract_filtered <- if (length(filtered_out_variant) > 0) {
    filtered_out_id <- match(filtered_out_variant, LD_data$ref_panel$variant_id)
    as.matrix(LD_data$combined_LD_matrix)[-filtered_out_id, -filtered_out_id]
  } else {
    as.matrix(LD_data$combined_LD_matrix)
  }
  
  return(list(sumstats = imputation_res, LD_mat = LD_extract_filtered))
}