#' Preprocess input data for RSS analysis
#'
#' This function preprocesses summary statistics and LD data for RSS analysis.
#' It performs allele quality control, flipping alleles as necessary, and removes
#' specified regions from the analysis.
#'
#' @param sumstats A data frame containing summary statistics with columns "chrom", "pos", "A1", and "A2".
#' @param LD_data A list containing combined LD variants data that is generated by load_LD_matrix.
#' @param skip_region A character vector specifying regions to be skipped in the analysis (optional).
#'                    Each region should be in the format "chrom:start-end" (e.g., "1:1000000-2000000").
#'
#' @return A processed data frame containing summary statistics after preprocessing.
#' @importFrom dplyr filter pull arrange
#' @importFrom tibble tibble
#' @importFrom tidyr separate
#' @importFrom magrittr %>%
#' @export
rss_input_preprocess <- function(sumstats, LD_data, skip_region = NULL) {
  # Check if required columns are present in sumstats
  required_cols <- c("chrom", "pos", "A1", "A2")
  missing_cols <- setdiff(required_cols, colnames(sumstats))
  if (length(missing_cols) > 0) {
    stop("Missing columns in sumstats: ", paste(missing_cols, collapse = ", "))
  }

  target_variants <- sumstats[, c("chrom", "pos", "A1", "A2")]
  ref_variants <- LD_data$combined_LD_variants

  allele_flip <- allele_qc(target_variants, ref_variants, sumstats,
    col_to_flip = c("beta", "z"),
    match_min_prop = 0.2, remove_dups = TRUE, remove_indels = FALSE,
    remove_strand_ambiguous = TRUE
  )

  if (!is.null(skip_region)) {
    skip_table <- tibble(region = skip_region) %>%
      separate(region, into = c("chrom", "start", "end"), sep = "[-:]")

    skip_variant <- c()
    for (region_index in 1:nrow(skip_table)) {
      variant <- allele_flip$target_data_qced %>%
        filter(chrom == skip_table$chrom[region_index] &
          pos > skip_table$start[region_index] &
          pos < skip_table$end[region_index]) %>%
        pull(variant_id)
      skip_variant <- c(skip_variant, variant)
    }

    allele_flip$target_data_qced <- allele_flip$target_data_qced %>%
      filter(!(variant_id %in% skip_variant))
  }

  sumstat_processed <- allele_flip$target_data_qced %>% arrange(pos)

  return(sumstat_processed)
}

#' Quality Control and Imputation based on SuSiE RSS
#'
#' Performs SuSiE RSS analysis with optional quality control steps that include
#' z-score and LD matrix discrepancy correction and imputation for outliers. It leverages
#' the `susie_rss` function for the core analysis and provides additional functionality
#' for handling data discrepancies and missing values.
#'
#' @param z Numeric vector of z-scores corresponding to the effect size estimates, with names matching the reference panel's variant IDs.
#' @param R Numeric matrix representing the LD (linkage disequilibrium) matrix.
#' @param ref_panel Data frame with 'chrom', 'pos', 'variant_id', 'A1', 'A2' column that matches the names of z.
#' @param bhat Optional numeric vector of effect size estimates.
#' @param shat Optional numeric vector of standard errors associated with the effect size estimates.
#' @param var_y Optional numeric value representing the total phenotypic variance.
#' @param n Optional numeric value representing the sample size used in the analysis.
#' @param L Initial number of causal configurations to consider in the analysis.
#' @param max_L Maximum number of causal configurations to consider when dynamically adjusting L.
#' @param l_step Step size for increasing L when the limit is reached during dynamic adjustment.
#' @param lamb Regularization parameter for the RAiSS imputation method.
#' @param rcond Condition number for the RAiSS imputation method.
#' @param R2_threshold R-squared threshold for the RAiSS imputation method.
#' @param minimum_ld Minimum number of LD values for the RAiSS imputation method.
#' @param impute Logical; if TRUE, performs imputation for outliers identified in the analysis.
#' @param output_qc Logical; if TRUE, includes QC-only results in the output.
#' @return A list containing the results of the SuSiE RSS analysis after applying quality control measures and optional imputation.
#' @importFrom susieR susie_rss
#' @importFrom magrittr %>%
#' @importFrom dplyr arrange
#' @export
susie_rss_qc <- function(sumstat, R, ref_panel, bhat = NULL, shat = NULL, var_y = NULL, n = NULL, L = 10, max_L = 20, l_step = 5,
                         lamb = 0.01, rcond = 0.01, R2_threshold = 0.6, minimum_ld = 5, impute = TRUE, output_qc = TRUE, coverage = 0.95) {
  z <- sumstat$z
  ## Input validation for z-scores and reference panel
  if (is.null(names(z))) {
    warning("Z-score names are NULL. Assuming names match reference panel variant_id.")
  } else if (!all(names(z) %in% ref_panel$variant_id)) {
    stop("Names of z-scores do not match the reference panel variant_id.")
  }

  ## Perform SuSiE RSS analysis with discrepancy correction
  LD_extract <- R[sumstat$variant_id, sumstat$variant_id, drop = FALSE]
  result <- susie_rss(
    z = z, R = LD_extract, bhat = bhat, shat = shat, var_y = var_y, n = n, L = L,
    correct_zR_discrepancy = TRUE, track_fit = TRUE, max_iter = 100
  )

    ## Extracting known z-scores excluding outliers
    if (!is.null(result$zR_outliers) & length(result$zR_outliers) != 0) {
      outlier <- result$zR_outliers

      known_zscores <- sumstat[-outlier, ]
      known_zscores <- known_zscores %>% arrange(pos)
    } else {
      known_zscores <- sumstat %>% arrange(pos)
    }

    ## Imputation logic using RAiSS or other methods
    imputation_res <- raiss(ref_panel, known_zscores, R,
      lamb = lamb, rcond = rcond,
      R2_threshold = R2_threshold, minimum_ld = minimum_ld
    )$result_filter

    ## Filter out variants not included in the imputation result
    filtered_out_variant <- setdiff(ref_panel$variant_id, imputation_res$variant_id)

    ## Update the LD matrix excluding filtered variants
    LD_extract_filtered <- if (length(filtered_out_variant) > 0) {
      filtered_out_id <- match(filtered_out_variant, ref_panel$variant_id)
      as.matrix(R)[-filtered_out_id, -filtered_out_id]
    } else {
      as.matrix(R)
    }

  return(list(sumstats = imputation_res, LD_mat = LD_extract_filtered))
}

#' Perform Quality Control on Summary Statistics
#'
#' This function performs quality control on the processed summary statistics using the specified method.
#' It can handle missing data imputation based on the provided options.
#'
#' @param input_processed A data frame containing the processed summary statistics.
#' @param LD_data A list containing the combined LD variants data generated by load_LD_matrix.
#' @param method The quality control method to use. Options are "rss_qc", "dentist", or "slalom" (default: "rss_qc").
#' @param impute Logical; if TRUE, performs imputation for missing data (default: TRUE).
#' @param impute_opts A list of imputation options including:
#'   - rcond: Condition number for the RAiSS imputation method (default: 0.01).
#'   - R2_threshold: R-squared threshold for the RAiSS imputation method (default: 0.6).
#'   - minimum_ld: Minimum number of LD values for the RAiSS imputation method (default: 5).
#'
#' @return A list containing the quality-controlled summary statistics and imputation results (if applicable).
#'   - sumstats_qc: The quality-controlled summary statistics data frame.
#'   - imputation_results: A list of imputation results (if impute = TRUE), including:
#'     - sumstats_imputed: The imputed summary statistics data frame.
#'     - imputation_metrics: A list of imputation performance metrics.
#'
#' @details This function applies the specified quality control method to the processed summary statistics.
#'   The available methods are:
#'   - "rss_qc": Applies the RSS QC quality control procedure (Sun and Dong et al 2023+)
#'   - "dentist": Applies the DENTIST quality control procedure (Chen et al 2021)
#'   - "slalom": Applies the SLALOM quality control procedure
#'
#'   If `impute` is set to TRUE, the function will perform missing data imputation using the RAiSS method based on the provided `impute_opts`.
#'   The imputation results will be included in the output list.
#'
#' @examples
#' # Perform RSS quality control without imputation
#' qc_results <- summary_stats_qc(input_processed, LD_data, method = "rss_qc", impute = FALSE)
#'
#' # Perform DENTIST quality control with imputation
#' qc_results <- summary_stats_qc(input_processed, LD_data, method = "dentist", impute = TRUE,
#'                                impute_opts = list(rcond = 0.05, R2_threshold = 0.7, minimum_ld = 10))
#'
#' @importFrom magrittr %>%
#' @export
summary_stats_qc <- function(input_processed, LD_data, method = c("rss_qc", "dentist", "slalom"), impute = TRUE,
                             impute_opts = list(rcond = 0.01, R2_threshold = 0.6, minimum_ld = 5)) {
  # Function body goes here
}