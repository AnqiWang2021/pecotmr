#' Preprocess input data for RSS analysis
#'
#' This function preprocesses summary statistics and LD data for RSS analysis.
#' It performs allele quality control, flipping alleles as necessary, and removes
#' specified regions from the analysis.
#'
#' @param sumstats A data frame containing summary statistics with columns "chrom", "pos", "A1", and "A2".
#' @param LD_data A list containing combined LD variants data that is generated by load_LD_matrix.
#' @param skip_region A character vector specifying regions to be skipped in the analysis (optional).
#'                    Each region should be in the format "chrom:start-end" (e.g., "1:1000000-2000000").
#'
#' @return A processed data frame containing summary statistics and LD with names after preprocessing.
#' @importFrom dplyr filter pull arrange
#' @importFrom tibble tibble
#' @importFrom tidyr separate
#' @importFrom magrittr %>%
#' @export
rss_input_preprocess <- function(sumstats, LD_data, skip_region = NULL) {
  # Check if required columns are present in sumstats
  required_cols <- c("chrom", "pos", "A1", "A2")
  missing_cols <- setdiff(required_cols, colnames(sumstats))
  if (length(missing_cols) > 0) {
    stop("Missing columns in sumstats: ", paste(missing_cols, collapse = ", "))
  }

  target_variants <- sumstats[, c("chrom", "pos", "A1", "A2")]
  ref_variants <- LD_data$combined_LD_variants

  allele_flip <- allele_qc(target_variants, ref_variants, sumstats,
    col_to_flip = c("beta", "z"),
    match_min_prop = 0.2, remove_dups = TRUE, remove_indels = FALSE,
    remove_strand_ambiguous = TRUE
  )

  if (!is.null(skip_region)) {
    skip_table <- tibble(region = skip_region) %>%
      separate(region, into = c("chrom", "start", "end"), sep = "[-:]")

    skip_variant <- c()
    for (region_index in 1:nrow(skip_table)) {
      variant <- allele_flip$target_data_qced %>%
        filter(chrom == skip_table$chrom[region_index] &
          pos > skip_table$start[region_index] &
          pos < skip_table$end[region_index]) %>%
        pull(variant_id)
      skip_variant <- c(skip_variant, variant)
    }

    allele_flip$target_data_qced <- allele_flip$target_data_qced %>%
      filter(!(variant_id %in% skip_variant))
  }

  sumstat_processed <- allele_flip$target_data_qced %>% arrange(pos)
  return(sumstat_processed)
}


#' Perform Quality Control based on SuSiE RSS
#'
#' This function performs quality control on summary statistics using SuSiE RSS.
#' It identifies and removes outliers based on z-score and LD matrix discrepancy correction.
#'
#' @param sumstats A data frame containing summary statistics with 'variant_id', 'z', and 'pos' columns.
#' @param R Numeric matrix representing the LD (linkage disequilibrium) matrix.
#' @param L Number of causal configurations to consider in the analysis.
#'
#' @return A list containing the quality-controlled summary statistics and updated LD matrix.
#'   - sumstats_qc: A data frame containing the quality-controlled summary statistics.
#'   - LD_mat_qc: The updated LD matrix excluding outlier variants.
#'
#' @details This function performs quality control on summary statistics using SuSiE RSS.
#'   It first extracts the z-scores from the `sumstats` data frame and performs SuSiE RSS analysis
#'   with discrepancy correction using the `susie_rss` function.
#'   
#'   Next, it identifies outlier variants based on the results of the SuSiE RSS analysis.
#'   It removes the outlier variants from the summary statistics and updates the LD matrix accordingly.
#'   
#'   Finally, it returns a list containing the quality-controlled summary statistics and the updated LD matrix.
#'
#' @importFrom susieR susie_rss
#' @export
susie_rss_qc <- function(sumstats, LD_mat, L = 10) {
  zScore <- sumstats$z
  # Check that LD_mat dimensions match the length of zScore
  if (!is.matrix(LD_mat) || nrow(LD_mat) != ncol(LD_mat) || nrow(LD_mat) != length(zScore)) {
    stop("LD_mat must be a square matrix with dimensions equal to the length of zScore.")
  }
  result <- susie_rss(
    z = zScore, R = LD_mat, L = L,
    correct_zR_discrepancy = TRUE, track_fit = TRUE, max_iter = 100
  )
  
  ## Identify outlier variants
  if (!is.null(result$zR_outliers) & length(result$zR_outliers) != 0) {
    outlier <- result$zR_outliers
    sumstat_qc <- sumstats[-outlier, ]
    LD_extract_qc <- as.matrix(LD_mat)[-outlier, -outlier]
  } else {
    sumstat_qc <- sumstats
    LD_extract_qc <- as.matrix(LD_mat)
  }
  
  return(list(sumstats = sumstat_qc, LD_mat = LD_extract_qc))
}

#' Perform Quality Control on Summary Statistics
#'
#' This function performs quality control on the processed summary statistics using the specified method.
#' It can handle missing data imputation based on the provided options.
#'
#' @param input_processed A data frame containing the processed summary statistics.
#' @param LD_data A list containing the combined LD variants data generated by load_LD_matrix.
#' @param method The quality control method to use. Options are "rss_qc", "dentist", or "slalom" (default: "rss_qc").
#' @param impute Logical; if TRUE, performs imputation for missing data (default: TRUE).
#' @param impute_opts A list of imputation options including:
#'   - rcond: Condition number for the RAiSS imputation method (default: 0.01).
#'   - R2_threshold: R-squared threshold for the RAiSS imputation method (default: 0.6).
#'   - minimum_ld: Minimum number of LD values for the RAiSS imputation method (default: 5).
#'
#' @return A list containing the quality-controlled summary statistics and imputation results (if applicable).
#'   - sumstats_qc: The quality-controlled summary statistics data frame.
#'   - imputation_results: A list of imputation results (if impute = TRUE), including:
#'     - sumstats_imputed: The imputed summary statistics data frame.
#'     - imputation_metrics: A list of imputation performance metrics.
#'
#' @details This function applies the specified quality control method to the processed summary statistics.
#'   The available methods are:
#'   - "rss_qc": Applies the RSS QC quality control procedure (Sun and Dong et al 2023+)
#'   - "dentist": Applies the DENTIST quality control procedure (Chen et al 2021)
#'   - "slalom": Applies the SLALOM quality control procedure
#'
#'   If `impute` is set to TRUE, the function will perform missing data imputation using the RAiSS method based on the provided `impute_opts`.
#'   The imputation results will be included in the output list.
#'
#' @examples
#' # Perform RSS quality control without imputation
#' qc_results <- summary_stats_qc(input_processed, LD_data, method = "rss_qc", impute = FALSE)
#'
#' # Perform DENTIST quality control with imputation
#' qc_results <- summary_stats_qc(input_processed, LD_data, method = "dentist", impute = TRUE,
#'                                impute_opts = list(rcond = 0.05, R2_threshold = 0.7, minimum_ld = 10))
#'
#' @export
summary_stats_qc <- function(sumstats, LD_data, method = c("rss_qc", "dentist", "slalom"), impute = TRUE,
                             impute_opts = list(rcond = 0.01, R2_threshold = 0.6, minimum_ld = 5, lamb=0.01)) {
  # assuming sumstats has been allele QC-ed, using rss_input_preprocess() function
  LD_extract <- LD_data$combined_LD_matrix[sumstats$variant_id, sumstats$variant_id, drop = FALSE]
  if (method == "rss_qc") {
    sumstats = susie_rss_qc(sumstats, LD_extract)
  }

  ## Imputation logic using RAiSS
  imputation_res <- raiss(LD_data$ref_panel, sumstats, LD_data$combined_LD_matrix,
                          lamb = impute_opts$lamb, rcond = impute_opts$rcond,
                          R2_threshold = impute_opts$R2_threshold, minimum_ld = impute_opts$minimum_ld
  )$result_filter
  
  ## Filter out variants not included in the imputation result
  filtered_out_variant <- setdiff(ref_panel$variant_id, imputation_res$variant_id)
  
  ## Update the LD matrix excluding filtered variants
  LD_extract_filtered <- if (length(filtered_out_variant) > 0) {
    filtered_out_id <- match(filtered_out_variant, ref_panel$variant_id)
    as.matrix(LD_data$combined_LD_matrix)[-filtered_out_id, -filtered_out_id]
  } else {
    as.matrix(LD_data$combined_LD_matrix)
  }
  
  return(list(sumstats = imputation_res, LD_mat = LD_extract_filtered))
}